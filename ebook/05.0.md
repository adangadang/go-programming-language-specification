# 5 常量

常量有布尔常量、分符常量、整型常量、浮点常量、 复数常量，和字符串常量之分。 字符、整数、浮点数和复数常量 统称数值常量。

常量值会出现在很多地方，比如[分符值](<04.10.md>)、[整型值](<04.7.md>)、[浮点值](<04.8.md>)、 [虚数值](<04.9.md>)，或是[字符串值](<04.11.md>)、指代常量的表达式、常量表达式、 常量结果的转换，或是一些内置函数比如unsafe.Sizeof（可适用于任意类型）、cap/len（用于 一些表达式）、real/imag（用于复数常量和虚数常量）的返回结果。布尔值可以用预声明的常量 true和false表示，预声明的标识符iota也用来表示常量。

一般来说，复数常量是常量表达式的一种，所以，偶们在那里讨论。

数值常量表示任意精度的值，不会溢出。

常量可能是有类型的或是无类型的。值常量、true、false、iota，和一些只包含无符号操作数的 常量表达式都是无符号的。

一个常量可能明确地来自于常量声明或是某个转换，也可能隐式地出现在变量声明 中，或是在一个表达式中被赋值或是作为操作数。如果一个常量不能用它对应的类型来表示，这么这就是个错误。比如说3.0 既可以当做整数也可以当做浮点数，然而2147483648.0 (等于1<<31)可以是float32、float64或是uint32类型，就是不能是 int32或是string类型。

并没有常量能代表 IEEE-754 的无穷大和非数值这两个值，但是math包中的 Inf、NaN、IsInf、和IsNaN 函数可以在运行时来返回或是测试这些值。

实现限制: 尽管我们说数值常量在语言中是任意精度的，但是一个编译器可能在实现的时候在内部只是用有限的精度来表示。不管怎么说，每一个实现必须满足：

- 整型常量至少 256 比特位；
- 浮点常量，也包括复数常量的一部分的浮点常量，至少应该有 256 比特位的尾数和一个 - 32 比特位的有符号指数部分；
- 如果不能精确地表示某个整数常量，就给出一个错误；
- 如果因为溢出不能表示一个浮点数或是复数常量，就给出一个错误；
- 如果因为精度原因不能表示一个浮点数或是复数常量，那么就四舍五入到最近的那个能表示的常量。

这些需求适用于值常量和常量表达式的求值结果。

## links
  * [目录](<preface.md>)
  * 下一节: [类型](<06.0.md>)